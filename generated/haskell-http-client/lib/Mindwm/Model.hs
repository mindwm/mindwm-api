{-
   Mindwm API

   This document describes the documentation, a collection of JSON schemas and example cloudevent and payloads

   OpenAPI Version: 3.1.0
   Mindwm API API version: 0.1.0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Mindwm.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Mindwm.Model where

import Mindwm.Core
import Mindwm.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- * Models


-- ** Clipboard
-- | Clipboard
data Clipboard = Clipboard
  { clipboardType :: !(Maybe Text) -- ^ "type"
  , clipboardSource :: !(Maybe Text) -- ^ "source"
  , clipboardData :: !(Maybe ClipboardPayload) -- ^ "data"
  , clipboardId :: !(Text) -- ^ /Required/ "id" - Identifies the event.
  , clipboardSpecversion :: !(Text) -- ^ /Required/ "specversion" - The version of the CloudEvents specification which the event uses.
  , clipboardDatacontenttype :: !(Maybe Text) -- ^ "datacontenttype" - Content type of the data value. Must adhere to RFC 2046 format.
  , clipboardDataschema :: !(Maybe Text) -- ^ "dataschema" - Identifies the schema that data adheres to.
  , clipboardSubject :: !(Maybe Text) -- ^ "subject" - Describes the subject of the event in the context of the event producer (identified by source).
  , clipboardTime :: !(Maybe DateTime) -- ^ "time" - Timestamp of when the occurrence happened. Must adhere to RFC 3339.
  , clipboardDataBase64 :: !(Maybe Text) -- ^ "data_base64" - Base64 encoded event payload. Must adhere to RFC4648.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Clipboard
instance A.FromJSON Clipboard where
  parseJSON = A.withObject "Clipboard" $ \o ->
    Clipboard
      <$> (o .:? "type")
      <*> (o .:? "source")
      <*> (o .:? "data")
      <*> (o .:  "id")
      <*> (o .:  "specversion")
      <*> (o .:? "datacontenttype")
      <*> (o .:? "dataschema")
      <*> (o .:? "subject")
      <*> (o .:? "time")
      <*> (o .:? "data_base64")

-- | ToJSON Clipboard
instance A.ToJSON Clipboard where
  toJSON Clipboard {..} =
   _omitNulls
      [ "type" .= clipboardType
      , "source" .= clipboardSource
      , "data" .= clipboardData
      , "id" .= clipboardId
      , "specversion" .= clipboardSpecversion
      , "datacontenttype" .= clipboardDatacontenttype
      , "dataschema" .= clipboardDataschema
      , "subject" .= clipboardSubject
      , "time" .= clipboardTime
      , "data_base64" .= clipboardDataBase64
      ]


-- | Construct a value of type 'Clipboard' (by applying it's required fields, if any)
mkClipboard
  :: Text -- ^ 'clipboardId': Identifies the event.
  -> Text -- ^ 'clipboardSpecversion': The version of the CloudEvents specification which the event uses.
  -> Clipboard
mkClipboard clipboardId clipboardSpecversion =
  Clipboard
  { clipboardType = Nothing
  , clipboardSource = Nothing
  , clipboardData = Nothing
  , clipboardId
  , clipboardSpecversion
  , clipboardDatacontenttype = Nothing
  , clipboardDataschema = Nothing
  , clipboardSubject = Nothing
  , clipboardTime = Nothing
  , clipboardDataBase64 = Nothing
  }

-- ** ClipboardPayload
-- | ClipboardPayload
data ClipboardPayload = ClipboardPayload
  { clipboardPayloadStart :: !(Maybe [Int]) -- ^ "start" - Starting position of clipboard selection [x,y]
  , clipboardPayloadStop :: !(Maybe [Int]) -- ^ "stop" - Ending position of clipboard selection [x,y]
  , clipboardPayloadData :: !(Maybe Text) -- ^ "data" - Clipboard data
  , clipboardPayloadType :: !(Maybe E'Type) -- ^ "type" - Clipboard type
  , clipboardPayloadContext :: !(Maybe ClipboardPayloadContext) -- ^ "context"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ClipboardPayload
instance A.FromJSON ClipboardPayload where
  parseJSON = A.withObject "ClipboardPayload" $ \o ->
    ClipboardPayload
      <$> (o .:? "start")
      <*> (o .:? "stop")
      <*> (o .:? "data")
      <*> (o .:? "type")
      <*> (o .:? "context")

-- | ToJSON ClipboardPayload
instance A.ToJSON ClipboardPayload where
  toJSON ClipboardPayload {..} =
   _omitNulls
      [ "start" .= clipboardPayloadStart
      , "stop" .= clipboardPayloadStop
      , "data" .= clipboardPayloadData
      , "type" .= clipboardPayloadType
      , "context" .= clipboardPayloadContext
      ]


-- | Construct a value of type 'ClipboardPayload' (by applying it's required fields, if any)
mkClipboardPayload
  :: ClipboardPayload
mkClipboardPayload =
  ClipboardPayload
  { clipboardPayloadStart = Nothing
  , clipboardPayloadStop = Nothing
  , clipboardPayloadData = Nothing
  , clipboardPayloadType = Nothing
  , clipboardPayloadContext = Nothing
  }

-- ** ClipboardPayloadContext
-- | ClipboardPayloadContext
-- Selection context
data ClipboardPayloadContext = ClipboardPayloadContext
  { clipboardPayloadContextWindow :: !(Maybe Text) -- ^ "window" - window id
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ClipboardPayloadContext
instance A.FromJSON ClipboardPayloadContext where
  parseJSON = A.withObject "ClipboardPayloadContext" $ \o ->
    ClipboardPayloadContext
      <$> (o .:? "window")

-- | ToJSON ClipboardPayloadContext
instance A.ToJSON ClipboardPayloadContext where
  toJSON ClipboardPayloadContext {..} =
   _omitNulls
      [ "window" .= clipboardPayloadContextWindow
      ]


-- | Construct a value of type 'ClipboardPayloadContext' (by applying it's required fields, if any)
mkClipboardPayloadContext
  :: ClipboardPayloadContext
mkClipboardPayloadContext =
  ClipboardPayloadContext
  { clipboardPayloadContextWindow = Nothing
  }

-- ** CloudEvent
-- | CloudEvent
-- CloudEvents Specification JSON Schema
data CloudEvent = CloudEvent
  { cloudEventId :: !(Text) -- ^ /Required/ "id" - Identifies the event.
  , cloudEventSource :: !(Text) -- ^ /Required/ "source" - Identifies the context in which an event happened.
  , cloudEventSpecversion :: !(Text) -- ^ /Required/ "specversion" - The version of the CloudEvents specification which the event uses.
  , cloudEventType :: !(Text) -- ^ /Required/ "type" - Describes the type of event related to the originating occurrence.
  , cloudEventDatacontenttype :: !(Maybe Text) -- ^ "datacontenttype" - Content type of the data value. Must adhere to RFC 2046 format.
  , cloudEventDataschema :: !(Maybe Text) -- ^ "dataschema" - Identifies the schema that data adheres to.
  , cloudEventSubject :: !(Maybe Text) -- ^ "subject" - Describes the subject of the event in the context of the event producer (identified by source).
  , cloudEventTime :: !(Maybe DateTime) -- ^ "time" - Timestamp of when the occurrence happened. Must adhere to RFC 3339.
  , cloudEventData :: !(Maybe CloudEventData) -- ^ "data"
  , cloudEventDataBase64 :: !(Maybe Text) -- ^ "data_base64" - Base64 encoded event payload. Must adhere to RFC4648.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CloudEvent
instance A.FromJSON CloudEvent where
  parseJSON = A.withObject "CloudEvent" $ \o ->
    CloudEvent
      <$> (o .:  "id")
      <*> (o .:  "source")
      <*> (o .:  "specversion")
      <*> (o .:  "type")
      <*> (o .:? "datacontenttype")
      <*> (o .:? "dataschema")
      <*> (o .:? "subject")
      <*> (o .:? "time")
      <*> (o .:? "data")
      <*> (o .:? "data_base64")

-- | ToJSON CloudEvent
instance A.ToJSON CloudEvent where
  toJSON CloudEvent {..} =
   _omitNulls
      [ "id" .= cloudEventId
      , "source" .= cloudEventSource
      , "specversion" .= cloudEventSpecversion
      , "type" .= cloudEventType
      , "datacontenttype" .= cloudEventDatacontenttype
      , "dataschema" .= cloudEventDataschema
      , "subject" .= cloudEventSubject
      , "time" .= cloudEventTime
      , "data" .= cloudEventData
      , "data_base64" .= cloudEventDataBase64
      ]


-- | Construct a value of type 'CloudEvent' (by applying it's required fields, if any)
mkCloudEvent
  :: Text -- ^ 'cloudEventId': Identifies the event.
  -> Text -- ^ 'cloudEventSource': Identifies the context in which an event happened.
  -> Text -- ^ 'cloudEventSpecversion': The version of the CloudEvents specification which the event uses.
  -> Text -- ^ 'cloudEventType': Describes the type of event related to the originating occurrence.
  -> CloudEvent
mkCloudEvent cloudEventId cloudEventSource cloudEventSpecversion cloudEventType =
  CloudEvent
  { cloudEventId
  , cloudEventSource
  , cloudEventSpecversion
  , cloudEventType
  , cloudEventDatacontenttype = Nothing
  , cloudEventDataschema = Nothing
  , cloudEventSubject = Nothing
  , cloudEventTime = Nothing
  , cloudEventData = Nothing
  , cloudEventDataBase64 = Nothing
  }

-- ** CloudEventData
-- | CloudEventData
-- The event payload.
data CloudEventData = CloudEventData
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CloudEventData
instance A.FromJSON CloudEventData where
  parseJSON = A.withObject "CloudEventData" $ \o ->
    pure CloudEventData
      

-- | ToJSON CloudEventData
instance A.ToJSON CloudEventData where
  toJSON CloudEventData  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CloudEventData' (by applying it's required fields, if any)
mkCloudEventData
  :: CloudEventData
mkCloudEventData =
  CloudEventData
  { 
  }

-- ** IoDocument
-- | IoDocument
data IoDocument = IoDocument
  { ioDocumentType :: !(Maybe Text) -- ^ "type"
  , ioDocumentSource :: !(Maybe Text) -- ^ "source"
  , ioDocumentData :: !(Maybe TmuxPaneIoDocument) -- ^ "data"
  , ioDocumentId :: !(Text) -- ^ /Required/ "id" - Identifies the event.
  , ioDocumentSpecversion :: !(Text) -- ^ /Required/ "specversion" - The version of the CloudEvents specification which the event uses.
  , ioDocumentDatacontenttype :: !(Maybe Text) -- ^ "datacontenttype" - Content type of the data value. Must adhere to RFC 2046 format.
  , ioDocumentDataschema :: !(Maybe Text) -- ^ "dataschema" - Identifies the schema that data adheres to.
  , ioDocumentSubject :: !(Maybe Text) -- ^ "subject" - Describes the subject of the event in the context of the event producer (identified by source).
  , ioDocumentTime :: !(Maybe DateTime) -- ^ "time" - Timestamp of when the occurrence happened. Must adhere to RFC 3339.
  , ioDocumentDataBase64 :: !(Maybe Text) -- ^ "data_base64" - Base64 encoded event payload. Must adhere to RFC4648.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IoDocument
instance A.FromJSON IoDocument where
  parseJSON = A.withObject "IoDocument" $ \o ->
    IoDocument
      <$> (o .:? "type")
      <*> (o .:? "source")
      <*> (o .:? "data")
      <*> (o .:  "id")
      <*> (o .:  "specversion")
      <*> (o .:? "datacontenttype")
      <*> (o .:? "dataschema")
      <*> (o .:? "subject")
      <*> (o .:? "time")
      <*> (o .:? "data_base64")

-- | ToJSON IoDocument
instance A.ToJSON IoDocument where
  toJSON IoDocument {..} =
   _omitNulls
      [ "type" .= ioDocumentType
      , "source" .= ioDocumentSource
      , "data" .= ioDocumentData
      , "id" .= ioDocumentId
      , "specversion" .= ioDocumentSpecversion
      , "datacontenttype" .= ioDocumentDatacontenttype
      , "dataschema" .= ioDocumentDataschema
      , "subject" .= ioDocumentSubject
      , "time" .= ioDocumentTime
      , "data_base64" .= ioDocumentDataBase64
      ]


-- | Construct a value of type 'IoDocument' (by applying it's required fields, if any)
mkIoDocument
  :: Text -- ^ 'ioDocumentId': Identifies the event.
  -> Text -- ^ 'ioDocumentSpecversion': The version of the CloudEvents specification which the event uses.
  -> IoDocument
mkIoDocument ioDocumentId ioDocumentSpecversion =
  IoDocument
  { ioDocumentType = Nothing
  , ioDocumentSource = Nothing
  , ioDocumentData = Nothing
  , ioDocumentId
  , ioDocumentSpecversion
  , ioDocumentDatacontenttype = Nothing
  , ioDocumentDataschema = Nothing
  , ioDocumentSubject = Nothing
  , ioDocumentTime = Nothing
  , ioDocumentDataBase64 = Nothing
  }

-- ** TmuxPaneIoDocument
-- | TmuxPaneIoDocument
data TmuxPaneIoDocument = TmuxPaneIoDocument
  { tmuxPaneIoDocumentInput :: !(Text) -- ^ /Required/ "input" - User input
  , tmuxPaneIoDocumentOutput :: !(Text) -- ^ /Required/ "output" - Command output (mix of stdout &amp; stderr)
  , tmuxPaneIoDocumentPs1 :: !(Text) -- ^ /Required/ "ps1" - ps1 (prompt) AFTER the input and output
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TmuxPaneIoDocument
instance A.FromJSON TmuxPaneIoDocument where
  parseJSON = A.withObject "TmuxPaneIoDocument" $ \o ->
    TmuxPaneIoDocument
      <$> (o .:  "input")
      <*> (o .:  "output")
      <*> (o .:  "ps1")

-- | ToJSON TmuxPaneIoDocument
instance A.ToJSON TmuxPaneIoDocument where
  toJSON TmuxPaneIoDocument {..} =
   _omitNulls
      [ "input" .= tmuxPaneIoDocumentInput
      , "output" .= tmuxPaneIoDocumentOutput
      , "ps1" .= tmuxPaneIoDocumentPs1
      ]


-- | Construct a value of type 'TmuxPaneIoDocument' (by applying it's required fields, if any)
mkTmuxPaneIoDocument
  :: Text -- ^ 'tmuxPaneIoDocumentInput': User input
  -> Text -- ^ 'tmuxPaneIoDocumentOutput': Command output (mix of stdout & stderr)
  -> Text -- ^ 'tmuxPaneIoDocumentPs1': ps1 (prompt) AFTER the input and output
  -> TmuxPaneIoDocument
mkTmuxPaneIoDocument tmuxPaneIoDocumentInput tmuxPaneIoDocumentOutput tmuxPaneIoDocumentPs1 =
  TmuxPaneIoDocument
  { tmuxPaneIoDocumentInput
  , tmuxPaneIoDocumentOutput
  , tmuxPaneIoDocumentPs1
  }


-- * Enums


-- ** E'Type

-- | Enum of 'Text' .
-- Clipboard type
data E'Type
  = E'Type'Primary -- ^ @"primary"@
  | E'Type'Secondary -- ^ @"secondary"@
  | E'Type'Clipboard -- ^ @"clipboard"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'Primary -> "primary"
  E'Type'Secondary -> "secondary"
  E'Type'Clipboard -> "clipboard"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "primary" -> P.Right E'Type'Primary
  "secondary" -> P.Right E'Type'Secondary
  "clipboard" -> P.Right E'Type'Clipboard
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s



